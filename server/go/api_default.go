/*
 * Jabberwocky
 *
 * Draft version
 *
 * API version: 0.0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"

	v1alpha1 "github.com/apache/camel-k/pkg/apis/camel/v1alpha1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/apache/camel-k/pkg/client/camel/clientset/versioned"
	kamel "github.com/apache/camel-k/pkg/client/camel/clientset/versioned"

	"gopkg.in/yaml.v3"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/tools/clientcmd"

	strimzi "./strimzi"
)

var kamelClient, kubeClient, ctx = localKubeConfiguration()

func localKubeConfiguration() (*versioned.Clientset, client.Client, context.Context) {
	kubeconfig := filepath.Join(os.Getenv("HOME"), ".kube", "config")
	log.Println("Using kubeconfig file: ", kubeconfig)
	cfg, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	checkFatalError(err)

	kamelClient, err := kamel.NewForConfig(cfg)
	checkFatalError(err)

	kubeClient, err := client.New(cfg, client.Options{})
	checkFatalError(err)

	ctx := context.Background()

	return kamelClient, kubeClient, ctx
}

func checkFatalError(err error) {
	if err != nil {
		log.Fatal(err)
		// Non recoverable error
		os.Exit(1)
	}
}

func AddChannel(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func AddConnector(w http.ResponseWriter, r *http.Request) {
	result, createError := createConnector(r)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if createError != nil {
		printResponseError(createError, w)
		return
	}
	w.WriteHeader(201)
	printResponse(result, w)
}

func createConnector(r *http.Request) (*v1alpha1.Kamelet, error) {
	var connector Connector
	_ = json.NewDecoder(r.Body).Decode(&connector)

	kameletSpec, _ := json.Marshal(connector.Configuration)
	fmt.Println("Spec: ", string(kameletSpec))

	kamelet := v1alpha1.Kamelet{}
	kamelet.Name = connector.Name
	kamelet.Spec.Definition.Default = &v1alpha1.JSON{kameletSpec}

	return kamelClient.CamelV1alpha1().Kamelets("default").Create(ctx, &kamelet, metav1.CreateOptions{
		metav1.TypeMeta{
			Kind:       "Kamelet",
			APIVersion: "camel.apache.org/v1alpha1"}, nil, ""})
}

func AddEventSink(w http.ResponseWriter, r *http.Request) {
	result, createError := createEventSourceOrSink(r, "destination")

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if createError != nil {
		printResponseError(createError, w)
		return
	}
	w.WriteHeader(201)
	printResponse(result, w)
}

func AddEventSource(w http.ResponseWriter, r *http.Request) {
	result, createError := createEventSourceOrSink(r, "source")

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if createError != nil {
		printResponseError(createError, w)
		return
	}
	w.WriteHeader(201)
	printResponse(result, w)
}

func createEventSourceOrSink(r *http.Request, kameletType string) (*v1alpha1.KameletBinding, error) {
	var eventSourceOrSink EventSourceOrSink
	_ = json.NewDecoder(r.Body).Decode(&eventSourceOrSink)

	emptyProps := []byte("{}")

	eventOrigin := v1alpha1.Endpoint{
		Ref: &corev1.ObjectReference{
			Kind:       "Kamelet",
			APIVersion: "camel.apache.org/v1alpha1",
			Name:       eventSourceOrSink.ConnectorSourceName},
		Properties: v1alpha1.EndpointProperties{emptyProps}}
	eventDestination := v1alpha1.Endpoint{
		Ref: &corev1.ObjectReference{
			Kind:       "KafkaTopic",
			APIVersion: "kafka.strimzi.io/v1beta1",
			Name:       eventSourceOrSink.ChannelName},
		Properties: v1alpha1.EndpointProperties{emptyProps}}

	kameletBinding := v1alpha1.NewKameletBinding("default", eventSourceOrSink.Name)

	// It's either a source or a sink, based on the origin of events
	if kameletType == "source" {
		kameletBinding.Spec = v1alpha1.KameletBindingSpec{Source: eventOrigin, Sink: eventDestination}
	} else {
		kameletBinding.Spec = v1alpha1.KameletBindingSpec{Source: eventDestination, Sink: eventOrigin}
	}

	return kamelClient.CamelV1alpha1().KameletBindings("default").Create(ctx, &kameletBinding, metav1.CreateOptions{
		metav1.TypeMeta{
			Kind:       "KameletBinding",
			APIVersion: "camel.apache.org/v1alpha1"}, nil, ""})
}

func printResponse(obj interface{}, w http.ResponseWriter) {
	data, _ := json.Marshal(obj)
	fmt.Fprintf(w, string(data))
}

func printResponseError(err error, w http.ResponseWriter) {
	w.WriteHeader(500)
	fmt.Fprintf(w, err.Error())
}

func GetChannelByName(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func GetChannels(w http.ResponseWriter, r *http.Request) {

	kafkaTopics := &unstructured.UnstructuredList{}
	kafkaTopics.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kafka.strimzi.io",
		Kind:    "KafkaTopic",
		Version: "v1beta1",
	})
	_ = kubeClient.List(context.Background(), kafkaTopics)

	channels := []Channel{}
	for _, kafkaTopic := range kafkaTopics.Items {
		parsedTopic, _ := strimzi.FromUnstructuredObject(kafkaTopic.Object)
		data, _ := json.Marshal(parsedTopic)
		channels = append(channels, Channel{parsedTopic.Metadata.Name, "kafka", string(data)})
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	printResponse(channels, w)
}

func GetConnectorByName(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func GetConnectors(w http.ResponseWriter, r *http.Request) {
	kamelets, _ := kamelClient.CamelV1alpha1().Kamelets("default").List(ctx, metav1.ListOptions{})

	connectors := []Connector{}
	for _, kamelet := range kamelets.Items {
		conf, _ := yaml.Marshal(kamelet)
		connectors = append(connectors, Connector{kamelet.Name, kamelet.Labels["camel.apache.org/kamelet.type"], string(conf)})
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	printResponse(connectors, w)
}

func GetEventSinkByName(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func GetEventSinks(w http.ResponseWriter, r *http.Request) {
	kameletBindings, _ := kamelClient.CamelV1alpha1().KameletBindings("default").List(ctx, metav1.ListOptions{})

	eventSinks := []EventSourceOrSink{}
	for _, kameletBinding := range kameletBindings.Items {
		if kameletBinding.Spec.Sink.Ref.Kind == "Kamelet" {
			// From sink perspective, Channel is the source, Source is the destination
			eventSinks = append(eventSinks, EventSourceOrSink{kameletBinding.Name, kameletBinding.Spec.Sink.Ref.Name, kameletBinding.Spec.Source.Ref.Name, nil})
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	printResponse(eventSinks, w)
}

func GetEventSourceByName(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func GetEventSources(w http.ResponseWriter, r *http.Request) {
	kameletBindings, _ := kamelClient.CamelV1alpha1().KameletBindings("default").List(ctx, metav1.ListOptions{})

	eventSources := []EventSourceOrSink{}
	for _, kameletBinding := range kameletBindings.Items {
		if kameletBinding.Spec.Source.Ref.Kind == "Kamelet" {
			// From source perspective, Source is the source, Channel is the destination
			eventSources = append(eventSources, EventSourceOrSink{kameletBinding.Name, kameletBinding.Spec.Source.Ref.Name, kameletBinding.Spec.Sink.Ref.Name, nil})
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	printResponse(eventSources, w)
}

func UpdateChannel(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func UpdateConnector(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func UpdateEventSink(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}

func UpdateEventSource(w http.ResponseWriter, r *http.Request) {
	printResponseError(errors.New("Not yet implemented"), w)
}
